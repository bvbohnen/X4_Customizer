'''
Support for log files, including generic messages.
Simplified from X3_Customizer, dropping support for file renaming
and hash comparisons, since all generated files should be safely
in their own extension folder.
'''
import os
from pathlib import Path
import json
from ..Common.Settings import Settings
from ..Common import Change_Log


class Plugin_Log_class:
    '''
    Container for logs generated by plugins.

    Attributes:
    * log_file
      - File object for the log, opened on the first write.
    * logging_function
      - Optional function which will be called by Print instead
        of doing the normal file write. The function should accept
        one argument, the message string.
    '''
    def __init__(self):
        self.log_file = None
        self.logging_function = None

    def Print(self, line):
        '''
        Write a line to the summary file.
        '''
        # If there is a logging_function attached, call it.
        if self.logging_function != None:
            self.logging_function(line)
            return

        # Open the file if needed.
        if self.log_file == None:
            self.log_file = open(Settings.Get_Plugin_Log_Path(), 'w')
        self.log_file.write(line + '\n')
        # Flush out to be a little safer against crashes.
        self.log_file.flush()
        return

    def Close(self):
        'Close the log file safely; the next Print will overwrite it.'
        if self.log_file != None:
            self.log_file.close()
        self.log_file = None
        return

# Static log object.
Plugin_Log = Plugin_Log_class()
    

class Customizer_Log_class:
    '''
    Container for logged information from the customizer framework,
    from a prior run or to be saved at the end of the current run.
    Separate logs should be used for each.

    Attributes:
    * version
      - String, version of the customizer.
    * file_paths_written
      - List of relative paths of files written out by the customizer.
      - Relative to the output extension folder.
      - When from an older run, these files should be removed or overwritten
        by the newer run.
    '''
    def __init__(self):
        # Always default to the current highest version.
        # When loading an older log, it can overwrite this.
        self.version = Change_Log.Get_Version()
        self.file_paths_written = []


    def Load(self, log_path):
        '''
        Load information from an existing log json file.
        Clears any existing information.
        If a log file is not found, nothing will be changed.
        '''
        # Version can be left as whatever, but need to clear the
        # file log.
        self.file_paths_written.clear()

        # If the file doesn't exist, return early.
        if not log_path.exists():
            return

        # Do a json load. Put in try/except for safety.
        try:
            with open(log_path, 'r') as file:
                log_dict = json.load(file)

            # Copy over fields.
            # TODO: think about how to safely do this if new fields are
            # added across version changes, and the old log is from the
            # prior version. Maybe use .get with defaults.
            self.version = log_dict['version']
            for relative_path in log_dict['file_paths_written']:
                self.file_paths_written.append(Path(relative_path))
        except Exception:
            # When something goes wrong, just leave it alone for now.
            pass
        return


    def Store(self):
        '''
        Store the current log information to a log json file.
        Overwrites any prior file.
        '''
        # Store fields into a dict for json to understand.
        log_dict = {}
        log_dict['version'] = self.version
        # Swap all paths to strings (since Paths don't have json support).
        log_dict['file_paths_written'] = [str(x) for x in self.file_paths_written]
        
        # Write the json, with indents for readability.
        with open(Settings.Get_Customizer_Log_Path(), 'w') as file:
            json.dump(log_dict, file, indent = 2)

        return
       

    def Record_File_Path_Written(self, path):
        '''
        Record the path of a file written by the customizer.
        '''
        # Convert to relative path and store.
        # Note: this might have to path upwards, which pathlib can't handle,
        #  so use os relpath.
        relpath = os.path.relpath(path, Settings.Get_Output_Folder())
        self.file_paths_written.append(path)
        return


    def Get_File_Paths_From_Last_Run(self):
        '''
        Returns a list of paths to files which were written on the
        last run.
        '''
        return self.file_paths_written

